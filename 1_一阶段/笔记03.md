## 变量

### 概念

它是内存中的一块存储区域（空间），有数据类型的限制，可以存入匹配类型的数据，并且根据需求随时改动其内容

### 特点

1. 变量是一款容器 ==> Java内存层面
2.  只能存储单个数据

### 定义格式

* 声明同时初始化：

    ~~~java
    数据类型 变量名 = 初始化值；
    ~~~

    

* 先声明后初始化：

    ~~~java
    数据类型 变量名；
    变量名 =初始化值；
    ~~~

### 变量名也是标识符之一

需要满足标识符的规则和规范



## 数据类型

### 基本数据类型 

* 整数型：

    | 又称   | 关键字 | 占用内存      | 取值范围         |
    | ------ | ------ | ------------- | ---------------- |
    |        | byte   | l byte (8bit) | [-2^7^,2^7^-1]   |
    | 短整型 | short  | 2byte (16bit) | [-2^15^,2^15^-1] |
    | 整型   | int    | 4byte (32bit) | [-2^31^,2^31^-1] |
    | 长整型 | long   | 8byte (64bit) | [-2^63^,2^63^-1] |

    **注意**：由于int是被主要使用的整数类型，所以程序中定义的整数型字面量全部都是默认类型int。

    整数型字面量属于默认类型int，所以在将整数型字面量赋值给长整型时，需要在数字末尾显式地标记L或l，告诉编译器这个字面量为长整型：

    ~~~java
    long l = 10000000000L
    ~~~


* 浮点型：

    | 类型         | 关键字 | 占用内存 |
    | ------------ | ------ | -------- |
    | 单精度浮点数 | float  | 4byte    |
    | 双精度浮点数 | double | 8byte    |

    **注意**：由于double是被主要使用的浮点类型，程序中定义的浮点型字面量全部都是默认类型double。

    浮点型字面量属于默认类型double，所以在将double浮点型字面量赋值给float浮点型时，需要在数字的末尾显式的标记F或f，告诉编译器这个字面量为float型：

    ~~~java
    float d = 3.14f
    ~~~

**注意**：浮点类型开辟空间大小远远大于整数型

* 布尔类型：

    ​	关键字：boolean

    ​	取值范围：true false

* 字符类型：

    ​	关键字：char

    ​	符号：单引号

    ​	特点：只能描述单个字符

    ​				可以描述转义字符

    ​				每个字符都对应一个编码值

    ​	需要记住的3个编码值：

    | 字符 | 编码值 |
    | ---- | ------ |
    | ‘0’  | 48     |
    | ‘A’  | 65     |
    | ‘a'  | 97     |

    常用转义字符：

    | 字符 | 含义       |
    | ---- | ---------- |
    | \\"  | 表示双引号 |
    | \\'  | 表示单引号 |
    | \\t  | 表示制表符 |
    | \\n  | 表示换行符 |



### 引用数据类型

数组、类、接口



### 基本数据类型的类型转换

* 自动类型转换（隐式类型转换），简称：自转

    * 特点：小容量类型 ->大容量类型 

        ​			或者当**字面量**大容量类型->小容量类型不发生精度损失时

    * 格式：

    ~~~java
    大容量数据类型 变量名2 = 变量名1;
    小容量数据类型 变量名3 = 字面量;
    ~~~

* 强制类型转换，简称：强转

    * 特点：大容量类型 ->小容量类型
    * 要求：需要显式地定义强制类型转换符：（需要被转换成的数据类型）
    * 格式:

    ~~~java
    小容量数据类型 变量名2 = （需要被转换成的数据类型）变量名1;
    ~~~

    **注意**：强制类型转换有精度丢失的风险

* 实例：

~~~java
int i = 200;
float f = i; //此处发生自动类型转换(浮点型的存储空间远远大于整型)
    
long 1 = 600L;
float f1 = l; //此处发生自动类型转换
~~~

* 类型转换底层流程图：

![](数据类型转换.png)





## 运算符



### 算数运算符

* 一元运算：

    | 运算符 | 运算                             | 实例                   | 结果              |
    | ------ | -------------------------------- | ---------------------- | ----------------- |
    | ++     | 自增（前），先（自增）运算再取值 | a = 3;<br />b = ++a;   | a =4<br />b = 4   |
    | ++     | 自增（后），先取值再（自增）运算 | a = 3;<br />b = a ++； | a = 4<br />b = 3  |
    | --     | 自减（前），先（自减）运算再取值 | a = 3;<br />b = --a;   | a = 2<br />b = 2  |
    | --     | 自减（后），先取值再（自减）运算 | a = 3;<br />b = a --   | a  = 2<br />b = 3 |
    
    

* 二元运算： **+  -  *  /  %**

    * 加符号 ：

        * 拼接操作：当加号两边至少有一个是字符串型（双引号修饰的）时，加号将进行拼接操作，结果为一个更长的字符串型

        * 运算操作：当加号两边都不是字符串类型时（即使是字符型）时，加号将进行运算操作。

            当进行的运算操作中有字符型时，编译器将对字符的编码进行运算

    * 除法运算：如果运算符两侧的数据类型都是整数型，那么最终结果会执行取整操作，向0取整

    ~~~java
    9 / 2;   // 结果为4
    (-9)/2   //结果为 -4
    ~~~

    想要保留小数，就将除法的其中一个数设为浮点型

    ~~~java
    9 *1.0 / 2 //结果为4.5
    ~~~

    

    * ***取模***（余）：

         结果的正负号和被模数保持一致
         
         运算过程,对整型数a,b 来说， a mod b:
         
         * 求整数商：c = [a/b] 这里的取整是向零取整
         * 计算模(余)： r = a - c * b

* 算数运算符两侧数据类型不一致时，绝大多数情况下取大容量数据类型

     但有特殊情况：

     ​		byte 和 byte 之间做运算 结果为int

     ​		short 和 short 之间做运算 结果为int

     ​	    byte 和 short 之间做运算 结果为int

     ​		char 和 char 之间做运算 结果为int

     

* 比较运算符： >  >=  <  <=  ==  !=

​                   值都是布尔值
