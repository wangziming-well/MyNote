# 代码块

属于类的成员之一

## 静态代码块

* 作用：将一些需要提前准备好的组件/容器对象，定义到静态代码块中，它们就可以随着类的加载提前创建完毕，就会被直接使用了。

* 特点：随着类的加载而加载，并且只会被执行一次；

* 定义格式：

    ~~~java
    static{
        //..
    }
    ~~~

    

## 构造代码块

* 作用：如果多个构造方法内部定义相同的代码，可以将其抽取出来，定义到构造代码块中，每次通过构造方法创建对象，够着代码块都会被执行一次

* 定义格式：

    ~~~java
    {
        //...
    }
    ~~~

* 注意：构造方法的首行会有隐式三步:

    * 1.super()；
    * 2.显式为非静态属性进行赋值操作***？***
    * 3.执行构造代码块
    * 【注意】2,3没有先天的先后顺序，谁先执行，取决于代码的定义顺序



## 局部代码块

* 作用：限制代码的使用范围，

* 定义格式：

    ~~~java
    {
        //...
    }
    ~~~

* 比较构造代码块和局部代码块

    * 定义位置：构造代码块定义在类的成员位置，而局部代码块定义在类的局部位置；



# 面对对象特性之继承性

* 关键字 `extends` 、`super`

* 好处：
    * 提高程序代码的复用性
    * 让类和类之间多了一层关系
* 弊端：让类和类之间多了一层关系（强耦合关系)

* 定义格式：

    ~~~java
    class A{
    
        
    }
    
    class B entends A{
        
    }
    ~~~

    A类：称为父类、基类、超类、superclass

    B类：称为子类、派生类、subclass

* Java语言中类和类之间只能满足单一继承

* 父类中的私有属性子类也可以继承；
* 构造方法在继承中：`super(..)`在子类构造方法中调用父类【注意】构造方法对super的调用必须是构造器的第一个语句



## 关键字super

### 作用一：

调用父类构造方法`super(...)`

* 如果一个类没有显式定义extends父类，那么这个类就是Object的子类；也就是说，Object是所有类的超类；Object的构造函数是没有隐式三步；也就是说，任何一个类的创建，必须有Object 的构造函数的进栈和出栈的动作；

* 任何类建议保存一个空参构造的原因：

    之后这个类可能有子类，如果子类没有显式定义构造方法，那么编译器会隐式地调用一个空参的构造器，

    这个构造器的首行会隐式地执行super（）空参方法，如果此时父类没有空参的构造方法，那么就会报形参列表长度不一致的错误

    还有一个原因，便于之后反射技术创建对象；

​		

### 作用2

* 就近原则，对于同名的成员（ 变量和方法），如果局部代码块中有，就优先调用局部变量；

    如果子类中有，就优先调用子类的成员变量

    只有在局部位置和子类中都没有时，编译器才会查找调用父类中的变量；

* 所以super可以调用父类的成员（非静态的），区分子类的同名变量和局部变量

* 调用父类的私有变量***?***



## 方法的重写

英文描述： overide 、overwrit

又被称为：复写、覆盖

为什么需要用到这种技术：

父类中的功能子类需要使用它，但是功能体（方法体）不完全适合子类的需求，此时子类就可以对其进行重写操作

前提条件：需要有继承关系；



要求：子类重写父类的方法，

1. 方法名必须相同
2. 方法的形参列表必须相同
3. 方法的返回值类型必须相同
4. 方法的访问修饰符(static)
5. 子类方法的权限修饰符必须不小于父类方法的权限

【补充】:Java中的权限修饰符（权限从小到大）

1. private
    1. 缺省

2. public



## 抽象

* 关键字：abstract
* 使用领域： 修饰类、修饰方法

* 定义格式：

~~~java
abstract class{
    
    权限修饰符 abstract 返回值类型 方法名();
}
~~~

* 抽象类无法实例化

* 直接父类和间接父类都是抽象类是，继承时，需要把直接父类和间接父类的抽象方法都重写；
* 抽象类也有构造方法；
* 语法层面，抽象类中可以不定义抽象方法；
* 抽象类可以定义具体类中的所有成员；

