# 接口



## 作用

有多个类，它们之间没有继承关系，也不在同一个继承体系下，它们内部都需要定义相同的功能（方法），如果每个类都定义一个，代码复用性差，此时我们可以将这个功能定义到接口中，让着多个类都实现这个接口，那么它们也都具备了该接口中相同的行为。



## 定义格式

* 关键字： `interface`
* 格式：

~~~java
interface 接口名{
    //....
}
~~~

java8以前，接口中只能定义两类成员：常量，抽象方法

接口中：

* 常量的定义格式：

~~~java
public static final 数据类型 常量名 = 常量值
~~~

简化形式：

~~~JAVA
数据类型 常量名 = 常量值;
~~~



* 抽象方法：

~~~java
public abstract 返回值类型 方法名(形参列表);
~~~

简化形式：

~~~java
返回值类型 方法名(形参列表);
~~~



【注意】：

​			接口定义存在的目的意义，就是为了给类所实现的



## 类实现接口

* 关键字： `implements`

* 定义格式：

    * 接口：

        ~~~java
        interface 接口名{
            //接口的成员
        }
        ~~~

    * 类：

        ~~~java
        class 类名 implements 接口名{
            //重写接口中的所有抽象方法是
        }
        ~~~


类实现接口，这个类就称为接口的实现类

## 注意

* 接口不能实例化对象
* 接口不是类，没有构造方法

* 可以多态接口类型的引用 指向实现类的对象

* 一个类可以实现多个接口

* 接口之间可以继承，这种继承可以多继承；接口可以有 多个父接口

* 类可以同时继承和实现：

    ~~~java
     class 子类名 extends 父类名 implements 接口名1,...,接口名n{
         //重写抽象方法
     }
    ~~~



## 使用第三方接口



### 比较器接口

1. 定制比较器：

    java.util.Comparator

    核心方法：

    int compare(T o1 , T o2) :比较用来排序的两个参数

    

2. 自然比较器：

    java.long.Compareble

    核心方法：

    int compareTo(T o):比较次对象与指定对象的顺序

    在某些情况下，某类型对于有些属性先天就可以具备比较能力，此时就可以让该类直接实现Comparable接口，重写compareTo方法，





java8及以后，接口中可以定义的成员：

除了常量和抽象方法以外，还可以定义一下的成员：

静态方法、默认方法





静态方法：

格式：

~~~java
public static 返回值类型 方法名(形参列表){
	//方法体
}
~~~

默认方法:

格式：

~~~java
public default 返回值类型 方法名(形参列表){
    //方法体
}
~~~



默认方法出现的意义：

在实际开发中，我们设计了一个接口，内部定义了10个抽象方法，有30个类都实现了该接口，它们都会重写这10个抽象方法。

随着项目的开展、版本的迭代，现在需要追加5个功能到该接口中，此时，如果将这5个功能都设计成抽象方法的话，此时之前的30个类都会报错，我们就需要在这30个类中都重写这5个抽象方法；但是30个类中可能就只有20个类需要关联用到这5个功能

导致另外的10个类为了满足Java的语法规则

也要重写这5个用不到的方法，开发成本上升了



此时Java设计者定义出了默认方法这种技术，讲需要扩展的5个功能都定义为默认方法，之前实现该接口的30个类不会受到影响





接口的静态方法通过接口名调用

接口和父类中都定义了相同名字的默认方法和非静态方法时，

如果类继承父类的同时实现了这个接口，在外界创建实现类的对象，调用同名方法，默认调用执行的是父类的该方法

类优先原则，首先访问父类的方法

如果想要访问接口的方法，需要在实现类中对其重写

语法：

~~~java
//实现类中假设同名方法为method

public void method(){
    Inter.super.method();
}
~~~



但如果多实现的接口中有相同名称的默认方法，

实现类中必须重写该方法；因为多个接口的优先级是一样的；

