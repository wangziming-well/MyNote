# 权限修饰符

Java中一共有四种：

1. private 私有的
2. 缺省
3. protected  受保护的
4. public     公共的



| 修饰符    | 本类中 | 同包不同类 | 不同包子父类 | 不同包不同类 |
| --------- | ------ | ---------- | ------------ | ------------ |
| private   | ○      | ×          | ×            | ×            |
| 缺省      | ○      | ○          | ×            | ×            |
| protected | ○      | ○          | ○            | ×            |
| public    | ○      | ○          | ○            | ○            |

实际应用中绝大部分只需要private 和public即可





# Object中的两个方法



## toString

~~~java
String toString(); 返回该对象的字符串表示
~~~

得到对象的属性信息

实例化对象后，直接调用对象名，会隐式默认调用Object类中的toString方法;

~~~java
class Person{
    
}
Person p = new Person();
System.out.println(p);
System.out.println(p.toStirng());
~~~

以上代码5,6行是等价的；

会返回对象的地址信息，在实际开发中，得到地址信息对程序员没有任何意义，我们更加想要得到的是对象的属性内容信息，所以我们需要在子类重写Object 的toString方法；



## equals方法

~~~java
boolean equals(Object obj) //:指使其他某个对线是否与此对象"相等"
~~~



Object中的equals方法比较的两个对象的地址值，实际运用中，根据需要重写；



# 设计模式

23种设计模式



## 单例设计模式：

作用：保证某类事物的对象只有一个

步骤：

1. 私有化本类所有的构造方法
2. 在本类中创建唯一对象；
3. 提供给外界获取唯一对象的方式

### 实现方式一：饿汉式

~~~java
public class Sun{
    
    private Sun(){}
    
    private static final Sun S =new Sun();
    
    public static Sun getInstance(){
        return S;
    }
    
}
~~~

优点：在多线程环境中能保证对象是唯一的

缺点：内存浪费



### 实现方法二：懒汉式



~~~java
public class Moon{
    
    private Moon(){}
    
    private static Moon M;
    
    public static Moon getInstance(){
        if(M =null){
            M = new Moon();
            return M;
        }
        return M;
    }
}
~~~

优点：不会造成内存的浪费

缺点： 多线程模式下不安全，有概率实例化多次对象，程序执行过程中容易造成数据混乱



解决方案：上锁



# 内部类

（了解部分）



在一个class的内部定义了一个class

外部的class称为外部类，内部的class称为内部类



在class的内部又有一个独立的内部结构，有必要的话可以将其单独定义一个class（内部类），

内部类需要依赖于外部类，不存在单独定义的情况。



## 分类



从定义位置上划分：

​		成员内部类

​		局部内部类



对成员内部类进行划分：

​		非静态成员内部类

​		静态成员内部类



对局部内部类进行划分：

​		局部内部类：定义在局部位置的有名字的内部类

​		匿名内部类：定义在局部位置的没有名字的内部类



## 匿名内部类

作用、意义：

场景搭建：

~~~java
class A{
    func(){
        //...
    }
}

class B extends A{
    @override
    func(){
        //....
	}
}

main(){
    new B().func();
}
~~~



### 定义格式：

* 情况一：和父类有关

~~~java
new 父类名(){
    //匿名子类成员的设计
}；
~~~



~~~java
new A(){
    @override
    func(){
        //....
	}
}.func();
~~~



* 情况二 ： 和接口有关

~~~java
new 接口名(){
    //匿名实现类成员的设计
}；
~~~



