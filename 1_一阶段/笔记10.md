# 面向对象



## 封装

* 关键字：

    `private`

* getter&setter

    * getter模板

        ~~~java
        public 返回值类型 get属性名()
        {
            return ...;
        }
        ~~~

    * setter模板

        ~~~java
        public void set属性名(形参列表)
        {
            属性名 = 变量名；
        }
        ~~~

        如果有需要可以加入数据合理性的校验



## this关键字

* this：记录正在被创建，或者已经被创建的类的地址

* 区分同名的成员变量和局部变量

* 本类构造方法之间的相互调用

  ~~~java
  this(形参列表)；
  ~~~

对this的调用必须是构造器中的第一个语句；



## static关键字

* 解释：静态的

* 理解：

    * 静态的和类有关，非静态的和对象有关
    * 类加载远远早于对象加载（静态的生命周期更长）

* 使用场景：

    * 修饰方法：静态方法（类方法）  

        相对的，有非静态方法（对象方法）

    * 修饰属性：静态属性（类属性）

        相对的，有非静态属性（对象属性）

使用类名调用static修饰的方法或者属性

~~~java
类名.static修饰的方法名()；
类名.static修饰的属性；
~~~

静态方法中不可以访问非静态的变量或者方法。



* 好处：直接通过类名访问调用，不需要创建对象，代码更加简洁，不需要在堆中开辟对象空间，节省内存

* 内存分析 **方法区**

    * 方法区：类加载在方法区，而且比对象创建早，比方法加载早；
    * 加载在方法区的同一个类有2个区域，静态区域和非静态区。
    * 非静态区中的变量方法，不会为静态属性，方法创建内存空间，只是简单（缓存）记录变量名；只有在对象实例化时，会为非静态区的方法属性开辟内存空间
    * 静态区中的属性会在静态区中开辟内存空间。而且空间中有默认值；

* 在类内：

    * `this. `调用对象属性或者对象方法

    * `类名. `调用类属性或者类方法

* 在类外：

    * `对象名.`调用对象属性或者对象方法
    * `类名.`调用类属性或者类方法

* 静态方法内部可以间接访问本类的非静态成员
    * 先创建类的对象
    * 通过对象调用非静态成员执行







java.lang 包下的类都是非常常用的类，不用导包就能直接用
